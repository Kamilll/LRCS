#ifndef _BLOCKWITHPOS_H_
#define _BLOCKWITHPOS_H_

#include "BlockPosNonContig.h"
#include "PosBlock.h"
#include <iostream>
using namespace std;

class BlockWithPos : public BlockPosNonContig
{
public:
	BlockWithPos();
	BlockWithPos(const BlockWithPos&);
	virtual ~BlockWithPos();
	Block* clone(Block&);
	void setBlock(Block* block);
	//virtual void setBuffer(int startpos_, int numValues_, byte* buffer_);
	virtual void resetBlock();
	// Iterator access to block
	virtual bool hasNext();
	virtual bool hasNext(int value_);
	virtual ValPos* getNext();
	virtual ValPos* peekNext();
	//virtual int getValue();
	//virtual unsigned int getPosition();
	virtual unsigned int getLastPosition();
	virtual unsigned int getEndPosition();
	//virtual void cutOffEnd(int endPos);

	virtual ValPos* getPairAtLoc(unsigned int loc_);
	
	//Like getPairAtLoc except set the regular pair variable rather than 
	//the utilityPair variable so can be called by getNext(). 
	virtual ValPos* getPairAtLocNotUtility(unsigned int loc_);
	//virtual Pair* getPairAtLocPair(unsigned int loc_);
	//virtual Pair* getPairAtDerivedLoc(unsigned int loc_);
	virtual int getCurrLoc();

	// return size of block (number of values)
	virtual int getSize();
	//return buffer size in block
	virtual int getSizeInBits();
	virtual ValPos* getStartPair();

	
	// Stream properties
	virtual bool isValueSorted();	
	virtual bool isPosSorted();
	
	// Block properties
	virtual bool isOneValue();
	
	//virtual bool isPosContiguous();
	virtual bool isBlockValueSorted();	
	virtual bool isBlockPosSorted();

protected:

	PosBlockIter* pbIter;
	Block* baseBlock;
	int startPos;

};

#endif //_BLOCKWITHPOS_H_
